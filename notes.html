<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Sticky Notes</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'><rect width='64' height='64' rx='12' fill='%230f172a'/><text x='50%' y='55%' text-anchor='middle' font-size='34' fill='%23fff' font-family='Arial'>N</text></svg>">
  <style>
    /* Simple drag handle cursor */
    .drag-handle { cursor: grab; }
    .drag-handle:active { cursor: grabbing; }
  </style>
</head>
<body class="bg-slate-900 text-slate-100 min-h-screen">
  <div class="max-w-5xl mx-auto p-4 sm:p-8">
    <!-- Header -->
    <div class="flex flex-col sm:flex-row gap-3 sm:items-center sm:justify-between">
      <h1 class="text-2xl sm:text-3xl font-bold">Sticky Notes</h1>
      <div class="flex flex-wrap gap-2">
        <button id="newNoteBtn" class="px-3 py-2 rounded-xl bg-indigo-600 hover:bg-indigo-700">+ New</button>
        <button id="exportBtn" class="px-3 py-2 rounded-xl bg-emerald-600 hover:bg-emerald-700">Export</button>
        <label class="px-3 py-2 rounded-xl bg-slate-700 hover:bg-slate-600 cursor-pointer">
          Import <input id="importInput" type="file" accept="application/json" class="hidden">
        </label>
        <button id="clearAllBtn" class="px-3 py-2 rounded-xl bg-rose-600 hover:bg-rose-700">Clear All</button>
      </div>
    </div>

    <!-- Search + Tag filter -->
    <div class="mt-5 grid grid-cols-1 sm:grid-cols-3 gap-3">
      <input id="searchInput" placeholder="Search notes‚Ä¶" class="col-span-2 w-full px-3 py-2 rounded-xl bg-slate-800 outline-none ring-1 ring-slate-700 focus:ring-indigo-600" />
      <input id="tagInput" placeholder="#tag filter (optional)" class="w-full px-3 py-2 rounded-xl bg-slate-800 outline-none ring-1 ring-slate-700 focus:ring-indigo-600" />
    </div>

    <!-- Notes Grid -->
    <div id="notesGrid" class="mt-6 grid gap-4 grid-cols-1 sm:grid-cols-2 lg:grid-cols-3"></div>

    <!-- Empty state -->
    <div id="emptyState" class="mt-16 text-center text-slate-400 hidden">
      <div class="text-6xl mb-4">üóíÔ∏è</div>
      <p>No notes yet. Click <span class="text-indigo-400">New</span> to create one.</p>
    </div>
  </div>

  <!-- Template -->
  <template id="noteTpl">
    <div class="note card group bg-slate-800 rounded-2xl ring-1 ring-slate-700 overflow-hidden">
      <div class="flex items-center justify-between p-3 border-b border-slate-700">
        <div class="flex items-center gap-2">
          <span class="drag-handle select-none text-slate-400">‚Üï</span>
          <input class="title w-full bg-transparent outline-none placeholder-slate-500" placeholder="Untitled note" />
        </div>
        <div class="flex items-center gap-2 opacity-0 group-hover:opacity-100 transition">
          <button class="pin px-2 py-1 rounded-lg bg-amber-600 hover:bg-amber-700 text-sm">Pin</button>
          <button class="del px-2 py-1 rounded-lg bg-rose-600 hover:bg-rose-700 text-sm">Delete</button>
        </div>
      </div>
      <div class="p-3">
        <textarea class="body w-full h-28 bg-transparent outline-none placeholder-slate-500" placeholder="Write something‚Ä¶"></textarea>
        <div class="mt-3 flex items-center justify-between gap-2">
          <input class="tags flex-1 bg-slate-900/60 rounded-lg px-3 py-2 outline-none placeholder-slate-500" placeholder="#tags comma or space separated" />
          <span class="text-xs text-slate-500 ml-2 updated"></span>
        </div>
      </div>
    </div>
  </template>

  <script>
    const STORAGE_KEY = 'sticky_notes_v1';

    /** @type {Array<{id:string,title:string,body:string,tags:string[],pinned:boolean,updated:number}>} */
    let notes = load();

    // DOM
    const grid = document.getElementById('notesGrid');
    const tpl = document.getElementById('noteTpl');
    const emptyState = document.getElementById('emptyState');
    const searchInput = document.getElementById('searchInput');
    const tagInput = document.getElementById('tagInput');

    document.getElementById('newNoteBtn').addEventListener('click', () => {
      const n = createNote();
      notes.unshift(n); // new on top
      save(); render();
    });

    document.getElementById('exportBtn').addEventListener('click', () => {
      const data = JSON.stringify(notes, null, 2);
      const blob = new Blob([data], { type: 'application/json' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'notes-backup.json';
      a.click();
      URL.revokeObjectURL(a.href);
    });

    document.getElementById('importInput').addEventListener('change', e => {
      const file = e.target.files?.[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = () => {
        try {
          const imported = JSON.parse(reader.result);
          if (Array.isArray(imported)) {
            // simple merge by id (overwrite existing)
            const map = new Map(notes.map(n => [n.id, n]));
            imported.forEach(n => map.set(n.id, normalizeNote(n)));
            notes = Array.from(map.values()).sort(sorter);
            save(); render();
          } else alert('Invalid file');
        } catch {
          alert('Invalid JSON');
        }
      };
      reader.readAsText(file);
      e.target.value = '';
    });

    document.getElementById('clearAllBtn').addEventListener('click', () => {
      if (confirm('Delete ALL notes?')) {
        notes = [];
        save(); render();
      }
    });

    searchInput.addEventListener('input', render);
    tagInput.addEventListener('input', render);

    function createNote() {
      const now = Date.now();
      return {
        id: crypto.randomUUID ? crypto.randomUUID() : String(now) + Math.random().toString(36).slice(2),
        title: '',
        body: '',
        tags: [],
        pinned: false,
        updated: now,
      };
    }

    function normalizeNote(n) {
      return {
        id: String(n.id || ''),
        title: String(n.title || ''),
        body: String(n.body || ''),
        tags: Array.isArray(n.tags) ? n.tags.map(t => String(t)) : [],
        pinned: Boolean(n.pinned),
        updated: Number(n.updated || Date.now()),
      };
    }

    function load() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return [];
        const arr = JSON.parse(raw);
        return Array.isArray(arr) ? arr.map(normalizeNote).sort(sorter) : [];
      } catch { return []; }
    }

    function save() {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(notes));
    }

    function sorter(a, b) {
      // pinned first, then newest updated
      if (a.pinned !== b.pinned) return a.pinned ? -1 : 1;
      return b.updated - a.updated;
    }

    function matchesFilters(n) {
      const q = searchInput.value.trim().toLowerCase();
      const tag = tagInput.value.trim().toLowerCase().replace(/^#/, '');
      const qok = !q || n.title.toLowerCase().includes(q) || n.body.toLowerCase().includes(q) || n.tags.join(' ').toLowerCase().includes(q);
      const tok = !tag || n.tags.map(t => t.toLowerCase()).includes(tag);
      return qok && tok;
    }

    function render() {
      grid.innerHTML = '';
      const filtered = notes.filter(matchesFilters).sort(sorter);
      emptyState.classList.toggle('hidden', filtered.length !== 0);

      filtered.forEach(n => {
        const node = tpl.content.firstElementChild.cloneNode(true);
        const title = node.querySelector('.title');
        const body = node.querySelector('.body');
        const tags = node.querySelector('.tags');
        const updated = node.querySelector('.updated');
        const del = node.querySelector('.del');
        const pin = node.querySelector('.pin');

        title.value = n.title;
        body.value = n.body;
        tags.value = n.tags.join(', ');
        updated.textContent = new Date(n.updated).toLocaleString();

        // events
        const onChange = () => {
          n.title = title.value;
          n.body = body.value;
          n.tags = tags.value
            .split(/[,\s]+/)
            .map(s => s.trim())
            .filter(Boolean);
          n.updated = Date.now();
          save(); // light autosave
          updated.textContent = new Date(n.updated).toLocaleString();
        };

        title.addEventListener('input', onChange);
        body.addEventListener('input', onChange);
        tags.addEventListener('input', onChange);

        del.addEventListener('click', () => {
          if (confirm('Delete this note?')) {
            notes = notes.filter(x => x.id !== n.id);
            save(); render();
          }
        });

        pin.textContent = n.pinned ? 'Unpin' : 'Pin';
        pin.addEventListener('click', () => {
          n.pinned = !n.pinned;
          n.updated = Date.now();
          save(); render();
        });

        grid.appendChild(node);
      });

      // simple drag-to-reorder (within filtered view)
      enableDragSort();
    }

    function enableDragSort() {
      const cards = Array.from(grid.children);
      cards.forEach(card => {
        const handle = card.querySelector('.drag-handle');
        let startIndex, from, ghost;

        handle.addEventListener('pointerdown', (e) => {
          from = card;
          startIndex = cards.indexOf(card);
          ghost = card.cloneNode(true);
          ghost.style.opacity = '0.5';
          ghost.style.pointerEvents = 'none';
          ghost.classList.add('ring-indigo-600');
          card.parentNode.insertBefore(ghost, card.nextSibling);
          card.style.position = 'absolute';
          card.style.width = ghost.getBoundingClientRect().width + 'px';
          card.style.zIndex = 50;
          card.setPointerCapture(e.pointerId);
        });

        handle.addEventListener('pointermove', (e) => {
          if (!from) return;
          const rect = grid.getBoundingClientRect();
          card.style.left = (e.clientX - rect.left - card.offsetWidth / 2) + 'px';
          card.style.top  = (e.clientY - rect.top  - card.offsetHeight / 2) + 'px';

          // find insertion point
          let before = null;
          for (const c of Array.from(grid.children)) {
            if (c === card || c === ghost) continue;
            const r = c.getBoundingClientRect();
            if (e.clientY < r.top + r.height / 2) { before = c; break; }
          }
          if (before) grid.insertBefore(ghost, before); else grid.appendChild(ghost);
        });

        handle.addEventListener('pointerup', () => {
          if (!from) return;
          card.style.position = '';
          card.style.left = '';
          card.style.top = '';
          card.style.zIndex = '';
          ghost.parentNode.insertBefore(card, ghost);
          ghost.remove();

          // persist new order (only among the currently filtered subset)
          const idsInDom = Array.from(grid.querySelectorAll('.note')).map(n => {
            const titleEl = n.querySelector('.title');
            // best-effort: map back to note via title/body snapshot
            return titleEl ? titleEl.value : '';
          });

          // rebuild notes order using DOM order + fallback by updated
          const filtered = notes.filter(matchesFilters);
          const rest = notes.filter(n => !filtered.includes(n));

          filtered.sort((a, b) => {
            return idsInDom.indexOf(a.title) - idsInDom.indexOf(b.title);
          });

          notes = [...filtered, ...rest].sort(sorter); // keep pin/newest logic
          save(); render();
          from = null;
        });
      });
    }

    // first paint
    render();
  </script>
</body>
</html>

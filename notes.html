<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Sticky Notes ‚Ä¢ Asianloop</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'><rect width='64' height='64' rx='12' fill='%230f172a'/><text x='50%' y='55%' text-anchor='middle' font-size='34' fill='%23fff' font-family='Arial'>N</text></svg>">
  <style>
    .drag-handle { cursor: grab; }
    .drag-handle:active { cursor: grabbing; }
  </style>
</head>
<body class="bg-slate-900 text-slate-100 min-h-screen">
  <div class="max-w-5xl mx-auto p-4 sm:p-8">

    <!-- Brand Header (white tile so your white-backed logo blends perfectly) -->
    <div class="bg-white text-slate-900 rounded-2xl shadow-lg ring-1 ring-slate-200 p-4 sm:p-5">
      <div class="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4">
        <div class="flex items-center gap-3">
          <!-- Replace src with your hosted URL if you prefer -->
          <img src="asianloop logo.png" alt="Asianloop Logo" class="h-12 w-auto rounded-xl ring-1 ring-slate-200 shadow-sm" />
          <div>
            <h1 class="text-2xl sm:text-3xl font-extrabold tracking-tight">Asianloop Sticky Notes</h1>
            <p class="text-sm text-slate-600">Quick notes. Local autosave. Export/import JSON.</p>
          </div>
        </div>
        <div class="flex flex-wrap gap-2">
          <button id="newNoteBtn" class="px-3 py-2 rounded-xl bg-indigo-600 hover:bg-indigo-700 text-white">+ New</button>
          <button id="exportBtn" class="px-3 py-2 rounded-xl bg-emerald-600 hover:bg-emerald-700 text-white">Export</button>
          <label class="px-3 py-2 rounded-xl bg-slate-900 text-white hover:bg-slate-800 cursor-pointer">
            Import <input id="importInput" type="file" accept="application/json" class="hidden">
          </label>
          <button id="clearAllBtn" class="px-3 py-2 rounded-xl bg-rose-600 hover:bg-rose-700 text-white">Clear All</button>
        </div>
      </div>

      <!-- Filters live inside the white header for a tidy look -->
      <div class="mt-4 grid grid-cols-1 sm:grid-cols-3 gap-3">
        <input id="searchInput" placeholder="Search notes‚Ä¶" class="col-span-2 w-full px-3 py-2 rounded-xl bg-white outline-none ring-1 ring-slate-300 focus:ring-indigo-600 placeholder-slate-400" />
        <input id="tagInput" placeholder="#tag filter (optional)" class="w-full px-3 py-2 rounded-xl bg-white outline-none ring-1 ring-slate-300 focus:ring-indigo-600 placeholder-slate-400" />
      </div>
    </div>

    <!-- Notes Grid on dark background -->
    <div id="notesGrid" class="mt-6 grid gap-4 grid-cols-1 sm:grid-cols-2 lg:grid-cols-3"></div>

    <!-- Empty state -->
    <div id="emptyState" class="mt-16 text-center text-slate-400 hidden">
      <div class="text-6xl mb-4">üóíÔ∏è</div>
      <p>No notes yet. Click <span class="text-indigo-400">New</span> to create one.</p>
    </div>
  </div>

  <!-- Template -->
  <template id="noteTpl">
    <!-- slightly lighter card so it stands out against bg -->
    <div class="note card group bg-slate-800 rounded-2xl ring-1 ring-slate-700 overflow-hidden">
      <div class="flex items-center justify-between p-3 border-b border-slate-700">
        <div class="flex items-center gap-2">
          <!-- tiny brand chip to tie back to header; remove if you don‚Äôt want it on each card -->
          <img src="logo.png" alt="Asianloop" class="h-5 w-auto rounded-md ring-1 ring-slate-600" />
          <input class="title w-full bg-transparent outline-none placeholder-slate-500" placeholder="Untitled note" />
        </div>
        <div class="flex items-center gap-2 opacity-0 group-hover:opacity-100 transition">
          <button class="pin px-2 py-1 rounded-lg bg-amber-600 hover:bg-amber-700 text-sm text-white">Pin</button>
          <button class="del px-2 py-1 rounded-lg bg-rose-600 hover:bg-rose-700 text-sm text-white">Delete</button>
        </div>
      </div>
      <div class="p-3">
        <textarea class="body w-full h-28 bg-transparent outline-none placeholder-slate-500" placeholder="Write something‚Ä¶"></textarea>
        <div class="mt-3 flex items-center justify-between gap-2">
          <input class="tags flex-1 bg-slate-900/60 rounded-lg px-3 py-2 outline-none placeholder-slate-500" placeholder="#tags comma or space separated" />
          <span class="text-xs text-slate-400 ml-2 updated"></span>
        </div>
      </div>
    </div>
  </template>

  <script>
    const STORAGE_KEY = 'sticky_notes_v1';
    /** @type {Array<{id:string,title:string,body:string,tags:string[],pinned:boolean,updated:number}>} */
    let notes = load();

    const grid = document.getElementById('notesGrid');
    const tpl = document.getElementById('noteTpl');
    const emptyState = document.getElementById('emptyState');
    const searchInput = document.getElementById('searchInput');
    const tagInput = document.getElementById('tagInput');

    document.getElementById('newNoteBtn').addEventListener('click', () => {
      const n = createNote();
      notes.unshift(n);
      save(); render();
    });

    document.getElementById('exportBtn').addEventListener('click', () => {
      const data = JSON.stringify(notes, null, 2);
      const blob = new Blob([data], { type: 'application/json' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'notes-backup.json';
      a.click();
      URL.revokeObjectURL(a.href);
    });

    document.getElementById('importInput').addEventListener('change', e => {
      const file = e.target.files?.[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = () => {
        try {
          const imported = JSON.parse(reader.result);
          if (Array.isArray(imported)) {
            const map = new Map(notes.map(n => [n.id, n]));
            imported.forEach(n => map.set(n.id, normalizeNote(n)));
            notes = Array.from(map.values()).sort(sorter);
            save(); render();
          } else alert('Invalid file');
        } catch {
          alert('Invalid JSON');
        }
      };
      reader.readAsText(file);
      e.target.value = '';
    });

    document.getElementById('clearAllBtn').addEventListener('click', () => {
      if (confirm('Delete ALL notes?')) {
        notes = [];
        save(); render();
      }
    });

    searchInput.addEventListener('input', render);
    tagInput.addEventListener('input', render);

    function createNote() {
      const now = Date.now();
      return {
        id: crypto.randomUUID ? crypto.randomUUID() : String(now) + Math.random().toString(36).slice(2),
        title: '',
        body: '',
        tags: [],
        pinned: false,
        updated: now,
      };
    }

    function normalizeNote(n) {
      return {
        id: String(n.id || ''),
        title: String(n.title || ''),
        body: String(n.body || ''),
        tags: Array.isArray(n.tags) ? n.tags.map(t => String(t)) : [],
        pinned: Boolean(n.pinned),
        updated: Number(n.updated || Date.now()),
      };
    }

    function load() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return [];
        const arr = JSON.parse(raw);
        return Array.isArray(arr) ? arr.map(normalizeNote).sort(sorter) : [];
      } catch { return []; }
    }

    function save() {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(notes));
    }

    function sorter(a, b) {
      if (a.pinned !== b.pinned) return a.pinned ? -1 : 1;
      return b.updated - a.updated;
    }

    function matchesFilters(n) {
      const q = searchInput.value.trim().toLowerCase();
      const tag = tagInput.value.trim().toLowerCase().replace(/^#/, '');
      const qok = !q || n.title.toLowerCase().includes(q) || n.body.toLowerCase().includes(q) || n.tags.join(' ').toLowerCase().includes(q);
      const tok = !tag || n.tags.map(t => t.toLowerCase()).includes(tag);
      return qok && tok;
    }

    function render() {
      grid.innerHTML = '';
      const filtered = notes.filter(matchesFilters).sort(sorter);
      emptyState.classList.toggle('hidden', filtered.length !== 0);

      filtered.forEach(n => {
        const node = tpl.content.firstElementChild.cloneNode(true);
        const title = node.querySelector('.title');
        const body = node.querySelector('.body');
        const tags = node.querySelector('.tags');
        const updated = node.querySelector('.updated');
        const del = node.querySelector('.del');
        const pin = node.querySelector('.pin');

        title.value = n.title;
        body.value = n.body;
        tags.value = n.tags.join(', ');
        updated.textContent = new Date(n.updated).toLocaleString();

        const onChange = () => {
          n.title = title.value;
          n.body = body.value;
          n.tags = tags.value.split(/[,\s]+/).map(s => s.trim()).filter(Boolean);
          n.updated = Date.now();
          save();
          updated.textContent = new Date(n.updated).toLocaleString();
        };

        title.addEventListener('input', onChange);
        body.addEventListener('input', onChange);
        tags.addEventListener('input', onChange);

        del.addEventListener('click', () => {
          if (confirm('Delete this note?')) {
            notes = notes.filter(x => x.id !== n.id);
            save(); render();
          }
        });

        pin.textContent = n.pinned ? 'Unpin' : 'Pin';
        pin.addEventListener('click', () => {
          n.pinned = !n.pinned;
          n.updated = Date.now();
          save(); render();
        });

        grid.appendChild(node);
      });

      enableDragSort();
    }

    function enableDragSort() {
      const cards = Array.from(grid.children);
      cards.forEach(card => {
        const handle = card.querySelector('.drag-handle') || card.querySelector('img');
        let startIndex, from, ghost;

        handle.addEventListener('pointerdown', (e) => {
          from = card;
          startIndex = cards.indexOf(card);
          ghost = card.cloneNode(true);
          ghost.style.opacity = '0.5';
          ghost.style.pointerEvents = 'none';
          ghost.classList.add('ring-indigo-600');
          card.parentNode.insertBefore(ghost, card.nextSibling);
          card.style.position = 'absolute';
          card.style.width = ghost.getBoundingClientRect().width + 'px';
          card.style.zIndex = 50;
          card.setPointerCapture(e.pointerId);
        });

        handle.addEventListener('pointermove', (e) => {
          if (!from) return;
          const rect = grid.getBoundingClientRect();
          card.style.left = (e.clientX - rect.left - card.offsetWidth / 2) + 'px';
          card.style.top  = (e.clientY - rect.top  - card.offsetHeight / 2) + 'px';

          let before = null;
          for (const c of Array.from(grid.children)) {
            if (c === card || c === ghost) continue;
            const r = c.getBoundingClientRect();
            if (e.clientY < r.top + r.height / 2) { before = c; break; }
          }
          if (before) grid.insertBefore(ghost, before); else grid.appendChild(ghost);
        });

        handle.addEventListener('pointerup', () => {
          if (!from) return;
          card.style.position = '';
          card.style.left = '';
          card.style.top = '';
          card.style.zIndex = '';
          ghost.parentNode.insertBefore(card, ghost);
          ghost.remove();

          // rebuild order by DOM visual order (best effort)
          const domCards = Array.from(grid.querySelectorAll('.note'));
          const idOrder = domCards.map((el, idx) => {
            const t = el.querySelector('.title')?.value || '';
            const b = el.querySelector('.body')?.value || '';
            return t + '|' + b.slice(0, 16);
          });

          const filtered = notes.filter(matchesFilters);
          const rest = notes.filter(n => !filtered.includes(n));

          filtered.sort((a, b) => {
            const keyA = a.title + '|' + a.body.slice(0, 16);
            const keyB = b.title + '|' + b.body.slice(0, 16);
            return idOrder.indexOf(keyA) - idOrder.indexOf(keyB);
          });

          notes = [...filtered, ...rest].sort(sorter);
          save(); render();
          from = null;
        });
      });
    }

    render();
  </script>
</body>
</html>
